---
title: "CIS 2020 analisis EQUO"
subtitle: "Análisis de datos de encuestas de EQUO y Podemos"
author: "ImJaviPerez"
date: "Marzo 2023"
output:
  html_document:
    toc: yes
    toc_depth: '4'
    df_print: paged
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
header-includes:
- \usepackage{xcolor}
- \usepackage{framed}
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead[RO,RE]{AnálisiS parcial}
- \fancyfoot{}
- \fancyfoot[RE,LO]{Votos 2020}
- \fancyfoot[LE,RO]{\thepage}
bibliography: BibliografiaME.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE)

#    include = FALSE prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.
#    echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.
#    message = FALSE prevents messages that are generated by code from appearing in the finished file.
#    warning = FALSE prevents warnings that are generated by code from appearing in the finished.
#    fig.cap = "..." adds a caption to graphical results.
#    results='asis' = output as-is, i.e., write raw results from R into the output document
```


```{r include=FALSE}
# Borrar toda las variables
### rm(list=ls())
```

***
```{r}
# List of libraries
library(foreign)
library(dplyr)
library(pander)
library(car)
library(ca)

library(gridExtra)
library(grid)
library(lattice)
library(ggplot2)
library(ggrepel)

library(factoextra)


library("RcmdrMisc")


```

```{r}
library(log4r)
# Create a new logger object with create.logger().
logger <- create.logger()
# Set the logger's file output.
logfile(logger) <- 'cis_2020_analisis.log'
# Set the current level of the logger.
level(logger) <- "DEBUG"
#level(logger) <- "INFO"
# At priority level INFO, a call to debug() won't print anything.
# debug(logger, 'A Debugging Message')
info(logger,  paste(Sys.time(), 'Starting script'))
# warn(logger, 'A Warning Message')
# error(logger, 'An Error Message')
# fatal(logger, 'A Fatal Error Message')

```


```{r}
# TODO
# http://destio.us.es/calvo/asignaturas/ge_esco/tutorialusargitgithubrstudio/UsarGitGithubconRStudio.html
# Seguir indicaciones de JRB
```


\pagebreak

# Análisis de correspondencias múltiples
Datos cualitativos procedentes de encuestas realizadas por el  [Centro de Investigaciones Sociológicas (CIS)](https://www.cis.es) en septiembre de 2020:
[Encuesta 3293/0 POSTELECTORAL DEL PAÍS VASCO. ELECCIONES AUTONÓMICAS 2020](https://www.cis.es/cis/opencm/ES/1_encuestas/estudios/listaMuestras.jsp?estudio=14522).

# Descripción del fichero de datos.

Para conocer las preguntas consultar el fichero: "Estudio: Postelectoral Autonómicas País Vasco 2020 Clave: ECIS3293" del link mencionado anteriormente.


```{r}
# We have to filter CIS 2020 data previously. It spends a lot of time for it's calculations, thus we have made those calculations in an other script and now we load those results.
require(log4r)

cis_2020_cuisine_file <- file.path(getwd(), "cis_2020_equo_cuisine.RData")
if (file.exists(cis_2020_cuisine_file)) {
  load(cis_2020_cuisine_file)
  log4r::info(logger, paste("cis_2020_cuisine_file (", cis_2020_cuisine_file, ") exists =", file.exists(cis_2020_cuisine_file)))
}else{
  log4r::error(logger, paste("File", cis_2020_cuisine_file, "DO NOT EXISTS. You must create this file using the script Cuisine.Rmd"))
  stop(paste("File", cis_2020_cuisine_file, "DO NOT EXISTS. You must create this file using the script Cuisine.Rmd"))}
```

```{r}
# P20 pollitical parties indices
# levels(cis_2020_df$P20)
P20_idx_11_pnv <- 5
P20_idx_12_bildu <- 6
P20_idx_2_psoe <- 2
P20_idx_21_podem <- 10
P20_idx_1_pp <- 1
P20_idx_18_vox <- 8
P20_idx_95_otro <- 14
P20_idx_96_blan <- 15
P20_idx_77_nul <- 13
P20_idx_97_abs <- 16
P20_idx_98_nr <- 17
P20_idx_99_nc <- 18

P20_idx_ciu <- 3
P20_idx_iu <- 4
P20_idx_pacm <- 7
P20_idx_ver <- 9
P20_idx_equ <- 11
P20_idx_escBl <- 12

# Test
# levels(cis_2020_df$P20)[c(P20_idx_1_pp, P20_idx_2_psoe, P20_idx_ciu, P20_idx_iu, P20_idx_11_pnv, P20_idx_12_bildu, P20_idx_pacm, P20_idx_18_vox, P20_idx_ver, P20_idx_21_podem, P20_idx_equ, P20_idx_escBl, P20_idx_77_nul, P20_idx_95_otro, P20_idx_96_blan,  P20_idx_97_abs, P20_idx_98_nr, P20_idx_99_nc)]
```


Ahora, realizamos el ACM en todas las columnas seleccionadas:
```{r ACM}
require(ca) 
cis_2020_equo_ca_00 <- mjca(cis_2020_EB_df[, included_cols_EB_idx])
```

Por defecto la función `mjca` toma el método de escalado `lambda = "adjusted"`, con lo que únicamente se consideran los valores propios obtenidos en el ACM mayores que $\frac{1}{Q} =$
```{r echo=FALSE, results='asis'}
eigen_inertia_e <- 1/Q
### cat("\\frac{1}{", Q, "} = ",round(1/Q, digits = 4), ".", sep = "")
cat(round(eigen_inertia_e, digits = 4), ".", sep = "")
```

```{r}
cis_2020_equo_ca_00_summ <- summary(cis_2020_equo_ca_00)
numDim <- length(which(cis_2020_equo_ca_00_summ$scree[,2] > (eigen_inertia_e/2)))

# if (numDim < 6) numDim <- 6
```
Por lo tanto en nuestro caso el número de dimensiones será:
```{r echo=FALSE, results='asis'}
cat(numDim)
```


## Datos objetivos y datos de opinión
Debemos tener en cuenta que hay una serie de variables que son datos objetivos de la persona como por ejemplo su provincia de empadronamiento. A estas características las llamaremos variables *ilustrativas*, que son:

```{r echo=FALSE, results='asis'}
# cat(paste0("'", included_cols_EB, "'", collapse = ", "), sep = "")
# 'PROV', 'MUN', 'CAPITAL', 'TIPO_TEL', 'SEXO', 'A0a', 'P10_2', 'P10_3', 'P10IMPRESA', 'P10DIGITAL', 'P10TV', 'P10RADIO', 'P11_1', 'P11_2', 'P11_3', 'P11_4', 'P11_5', 'P11_7', 'P11_9', 'P12_1', 'P12_2', 'P12_3', 'P12_4', 'P12_5', 'P12_6', 'P12_7', 'P12_9', 'P14A_11', 'P14A_12', 'P14A_2', 'P14A_21', 'P14A_1', 'P14A_18', 'P14A_95', 'P14A_98', 'P15A_11', 'P15A_12', 'P15A_2', 'P15A_21', 'P15A_1', 'P15A_18', 'P15A_95', 'P15A_98', 'P16', 'P16A_11', 'P16A_12', 'P16A_2', 'P16A_21', 'P16A_1', 'P16A_18', 'P16A_95', 'P16A_98', 'P17_3', 'P20A_2', 'P21B_2', 'P21C', 'PARTICIPACIONA', 'P27', 'RELIGION', 'ESTADOCIVIL', 'CNO11', 'RELALAB', 'IA_APLAZADA', 'IA_MODIFICADA', 'IA_SUPERVISADA', 'RVAUTO20', 'TAMUNI_GRUPO', 'EDAD_GRUPO', 'P1_GRUPO', 'P1A_GRUPO', 'P1B_GRUPO', 'P2_GRUPO', 'P3_1_GRUPO', 'P3_2_GRUPO', 'P3_3_GRUPO', 'P3_4_GRUPO', 'P4_GRUPO', 'P5_GRUPO', 'P5A_GRUPO', 'P6_GRUPO', 'P7_GRUPO', 'P8_1_GRUPO', 'P8_2_GRUPO', 'P8_3_GRUPO', 'P8_4_GRUPO', 'P9_GRUPO', 'P9A_GRUPO', 'P9B_GRUPO', 'P10_1_GRUPO', 'P10A_GRUPO', 'P10B_GRUPO', 'P10C_GRUPO', 'P10D_GRUPO', 'P13_1_GRUPO', 'P13_2_GRUPO', 'P13_3_GRUPO', 'P13_4_GRUPO', 'P13_5_GRUPO', 'P14_GRUPO', 'P15_GRUPO', 'P17_1_GRUPO', 'P17_2_GRUPO', 'P18_GRUPO', 'P18A_GRUPO', 'P18B_GRUPO', 'P19_GRUPO', 'P19A01_GRUPO', 'P19A02_GRUPO', 'P20_GRUPO', 'P20A_1_GRUPO', 'P21_GRUPO', 'P21A_GRUPO', 'P21B_1_GRUPO', 'P22_GRUPO', 'P23_GRUPO', 'P24_1_GRUPO', 'P24_2_GRUPO', 'P24_3_GRUPO', 'P24_4_GRUPO', 'P24_5_GRUPO', 'P24_6_GRUPO', 'P24_7_GRUPO', 'RECUVOTOA_GRUPO', 'P26_1_GRUPO', 'P26_2_GRUPO', 'P26_3_GRUPO', 'P26_4_GRUPO', 'P26_5_GRUPO', 'P26_6_GRUPO', 'P28_GRUPO', 'P29_GRUPO', 'PARTICIPACIONG_GRUPO', 'RECUVOTOG_GRUPO', 'ESCIDEOL_GRUPO', 'ESCIDEOLPAR_1_GRUPO', 'ESCIDEOLPAR_2_GRUPO', 'ESCIDEOLPAR_3_GRUPO', 'ESCIDEOLPAR_4_GRUPO', 'ESCIDEOLPAR_5_GRUPO', 'ESCIDEOLPAR_6_GRUPO', 'ESCIDEOLPAR_7_GRUPO', 'NIVELESTENTREV_GRUPO', 'FRECUENCIARELI_GRUPO', 'SITLAB_GRUPO', 'CLASESOCIAL_GRUPO', 'IA_E1_DIA_GRUPO', 'IA_E2_GRUPO', 'IA_E4_GRUPO', 'IA_C2_GRUPO', 'P19ACOM_GRUPO', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO', 'ESTUDIOS_GRUPO', 'CLASESUB_GRUPO'

# Select some illustrative variables
illustrative_vars_v01 <- c('PROV', 'MUN', 'CAPITAL', 'TIPO_TEL', 'SEXO', 'A0a', 
                       'PARTICIPACIONA', 'RECUVOTOA_GRUPO', 
                       'PARTICIPACIONG_GRUPO', 'RECUVOTOG_GRUPO', 
                       'ESTADOCIVIL', 'SITLAB_GRUPO', 'CNO11', 'RELALAB', 
                       'IA_APLAZADA', 'IA_MODIFICADA', 'IA_SUPERVISADA', 'P20_GRUPO',
                       'RVAUTO20', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO', 'ESTUDIOS_GRUPO', 
                       'TAMUNI_GRUPO', 'EDAD_GRUPO', 'P1_GRUPO', 'P1A_GRUPO', 'P1B_GRUPO', 'P2_GRUPO', 
                       'NIVELESTENTREV_GRUPO', 
                       'IA_E1_DIA_GRUPO', 'IA_E2_GRUPO', 'IA_E4_GRUPO', 'IA_C2_GRUPO')

# illustrative_vars <- c('RECUVOTOA_GRUPO', 'RECUVOTOG_GRUPO', 'RVAUTO20_GRUPO', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO')

# JRB: Incluir edad, tamano municipio, sexo, situacion laboral, estudios
illustrative_vars_v02 <- c('PROV', 'MUN', 'CAPITAL', 'TIPO_TEL', 
                       'RECUVOTOA_GRUPO', 'RECUVOTOG_GRUPO', 
                       'ESTADOCIVIL', 
                       'P1_GRUPO', 'P1A_GRUPO', 'P1B_GRUPO', 'P2_GRUPO', 
                       'IA_APLAZADA', 'IA_MODIFICADA', 'IA_SUPERVISADA', 'P20_GRUPO',
                       'RVAUTO20', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO', 
                       'IA_E1_DIA_GRUPO', 'IA_E2_GRUPO', 'IA_E4_GRUPO', 'IA_C2_GRUPO')

# JRB: Incluir edad, tamano municipio, sexo, situacion laboral, estudios, nacionalidad, lugar de nacimiento, comunidad autonoma de nacimiento, lengua materna
illustrative_vars_v03 <- c('PROV', 'MUN', 'CAPITAL', 'TIPO_TEL', 
                       'RECUVOTOA_GRUPO', 'RECUVOTOG_GRUPO', 
                       'ESTADOCIVIL',  
                       'IA_APLAZADA', 'IA_MODIFICADA', 'IA_SUPERVISADA', 'P20_GRUPO',
                       'RVAUTO20', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO', 
                       'IA_E1_DIA_GRUPO', 'IA_E2_GRUPO', 'IA_E4_GRUPO', 'IA_C2_GRUPO')

illustrative_vars <- illustrative_vars_v03
# Calculate spare variables
opinion_vars <- included_cols_EB[which(!(included_cols_EB %in% illustrative_vars))]

cat(paste0("`",illustrative_vars, "`", collapse = ", "), sep = "")

# length(illustrative_vars) + length(opinion_vars)
```

El resto de preguntas pueden considerarse de opinión. El ACM trata de ubicar los datos objetivos entre las diferentes escalas de opiniones.

# Selección de dimensiones más representativas

Se realiza una primera tentativa de ACM sólo con las variables de opinión:
```{r}
# Queremos representar algunas variables ilustrativas como columnas suplementarias.
# Por tanto hay que reordenar el dataframe poniendo las ilustrativas al final.
# Ademas debemos elegir lambda = "Burt"
cis_2020_acm_EB_df <- cis_2020_EB_df[,c(opinion_vars, illustrative_vars)]
# Seleccion de columnas suplementarias para mostar en el plano factorial
suplementary_cols <- c('RECUVOTOA_GRUPO', 
                       'RECUVOTOG_GRUPO', 
                       'RVAUTO20', 'P20_GRUPO', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO')

suplementary_cols_idx <- which(colnames(cis_2020_acm_EB_df) %in% suplementary_cols)
opinion_vars_idx <- which(colnames(cis_2020_acm_EB_df) %in% opinion_vars)
```


```{r ACM01}
require(ca)
### cis_2020_ca_opi01 <- mjca(cis_2020_acm_EB_df[,opinion_vars], nd = numDim)
cis_2020_ca_opi01 <- mjca(cis_2020_acm_EB_df, nd = numDim, lambda = "Burt", supcol = suplementary_cols_idx, subsetcol = opinion_vars_idx)

cis_2020_ca_opi01_summ <- summary(cis_2020_ca_opi01)
# print(cis_2020_ca_opi01_summ)

plot.mjca(cis_2020_ca_opi01, labels = c(2,0))
# plot.mjca(cis_2020_ca_opi01)
```

Inercias de los autovalores principales:
```{r}
require(pander)
aux_tbl <- as.data.frame(cis_2020_ca_opi01_summ$scree[1:numDim,])
colnames(aux_tbl) <- c("Dim", "Valor", "%", "% acumul")
# panderOptions()
pander(aux_tbl, digits = c(1,5,3,3), keep.trailing.zeros = TRUE, caption = "Porcentaje de varianza explicada por cada autovalor.")
```

```{r}
# Save factors information
# We will get a data.frame with: "name", "mass", " qlt", " inr" and information of every factor: "k", "cor" and "ctr"
require(dplyr)
cis_2020_ca_opi01_factor <- dplyr::bind_rows(cis_2020_ca_opi01_summ$columns)
colnames(cis_2020_ca_opi01_factor) <- c(c("name", "mass", "qlt", "inr"), paste0(c("k", "cor", "ctr"), rep(1:numDim, each=3)))
```

Con 
```{r echo=FALSE, results='asis'}
cat(numDim)
```
 dimensiones se explica el 
```{r echo=FALSE, results='asis'}
# cat(round(100 * sum(cis_2020_ca_opi01$inertia.e[1:numDim]), digits = 1))
cat(cis_2020_ca_opi01_summ$scree[numDim,][4])
```
 % de la varianza.


Seleccionamos las modalidades más importantes de cada factor.
```{r}
percet_eigenvalue <- 0.85
```
```{r}
# Returns a data.frame sorted by contribution. It includes the minimum number of categories that covers percet_eigenvalue
factor_categories <- function(columns_factors, num_factor, percet_eigenvalue){
  k_idx <-   4+3*(num_factor-1)+1
  cor_idx <- 4+3*(num_factor-1)+2
  ctr_idx <- 4+3*(num_factor-1)+3
  
  # Sort by its contribution
  fctr_contribution_sort <- base::sort(columns_factors[,ctr_idx], decreasing = TRUE, index.return = TRUE)
  # Calculate percet_eigenvalue of whole eigenvalue
  i <- round(percet_eigenvalue*sum(columns_factors[,ctr_idx], na.rm = TRUE))
  # Calculate number of variables
  num_categories <- which.max(cumsum(fctr_contribution_sort$x) >= i)
  #  cbind() returns a matrix, and a matrix can only hold one data type we must use data.frame()
  table <- data.frame(1:num_categories,
                      columns_factors$name[fctr_contribution_sort$ix[1:num_categories]],
                      columns_factors$qlt[fctr_contribution_sort$ix[1:num_categories]],
                      columns_factors[,k_idx][fctr_contribution_sort$ix[1:num_categories]],
                      columns_factors[,cor_idx][fctr_contribution_sort$ix[1:num_categories]],
                      fctr_contribution_sort$x[1:num_categories],
                      round(100*fctr_contribution_sort$x[1:num_categories] / sum(fctr_contribution_sort$x), digits = 1))
  
  colnames(table) <- c("n", "Variable:modalidad", "qlt", "k", "cor", "ctr", "%")

  return(table)
}
```

Ya se dijo que se iban a representar 
```{r echo=FALSE, results='asis'}
cat(numDim)
```
 dimensiones.
 
Se analiza el contenido de cada dimensión de una en una teniendo en cuenta el significado de cada parámetro obtenido:

 + `qlt`: representa la *calidad* de esa modalidad. Es el $cos^2$ y mide el grado de asociación de una modalidad con esa dimensión.
 + `k`: nos da las coordenadas de la modalidad en esa dimensión (en ese eje).
 + `cor`: correlaciones al cuadrado entre la modalidad y la dimensión.
 + `ctr`: para interpretar cada dimensión se analizan las contribuciones  absolutas (`ctr`). Esta columna es la que realmente representa cuánto de importante es una modalidad dentro de esa dimensión. 

Disponemos de 
```{r echo=FALSE, results='asis'}
cat(length(opinion_vars))
```
 variables que abarcan 
```{r echo=FALSE, results='asis'}
i <- 0
for (j in opinion_vars) {
  i <- i + nlevels(cis_2020_acm_EB_df[,j])
}
cat(i)
```
 modalidades. Precisamente cada una de estas modalidades va a contribuir (`ctr`) a crear cada dimensión.


## Dimensión 1
```{r}
num_categories_to_show <- 35
```

```{r}
i <- 1
# We want to show positive and negative categories of this dimension. And it is possible that only one side explains the wanted percentage, so we have to take extra categories from the other side to show.
# table with big percentage of eigenvalue
aux_tbl <- factor_categories(cis_2020_ca_opi01_factor, i, percet_eigenvalue)


# Select number of positive categories of table
n_categories_k_positive <- ifelse(length(which(aux_tbl$k > 0)) < num_categories_to_show, length(which(aux_tbl$k > 0)), num_categories_to_show)
# Select number of positive categories of table
n_categories_k_negative <- ifelse(length(which(aux_tbl$k < 0)) < num_categories_to_show, length(which(aux_tbl$k < 0)), num_categories_to_show)
```

En el **lado positivo del eje** las modalidades mejor representadas son:

```{r}
# Show positive categories
aux_idx <- which(aux_tbl$k > 0)[1:n_categories_k_positive]

require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_positive, " modalidades más significativas del eje positivo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```
```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k > 0)], n = n_categories_k_positive))
cat(paste0("`", str_aux_1, "`", collapse = ", "), ".", sep = "")
```


Para explicar el significado de un eje, hay que ver la contribución (`ctr`) de cada modalidad dentro de esa parte del eje. A continuación se explican las modalidades más significativa de este lado del eje en orden de preguntas (no por su contribución):

 + `ESCIDEOLPAR_1_GRUPO:NS_NC`, `ESCIDEOLPAR_2_GRUPO:NS_NC`, `ESCIDEOLPAR_3_GRUPO:NS_NC`, `ESCIDEOLPAR_4_GRUPO:NS_NC`, `ESCIDEOLPAR_5_GRUPO:NS_NC`, `ESCIDEOLPAR_6_GRUPO:NS_NC`, `ESCIDEOLPAR_7_GRUPO:NS_NC` =  No sabe o no contesta sobre la escala ideológica de ningún partido.
 + `P5_GRUPO:No alineado/a` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P5'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P5_GRUPO)[7])
```
 + `P5A_GRUPO:N.C.` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P5A'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P5A_GRUPO)[8])
```
 + `P6_GRUPO:Nada` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P6'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P6_GRUPO)[4])
```
 + `P7_GRUPO:Con ningún interés` = No pusieron ningún interés en seguir la campaña.
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P7')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P7_GRUPO)[4])
```
 

 + `P8_1_GRUPO:Nada`, `P8_2_GRUPO:Nada`, `P8_3_GRUPO:Nada` = Grado de utilidad de la campaña electoral de las elecciones autonómicas del País Vasco de 2020 en diferentes aspectos de la decisión de voto: 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P8_1', 'P8_2', 'P8_3')], collapse = " / "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P8_1_GRUPO)[4])
```

 + `P9_GRUPO:N.S.`
 + `P10_1_GRUPO:(NO LEER) No se informó, no le interesa la política`, `P10_2:N.C.`, `P10DIGITAL:No menciona`
 + `P12_1:No menciona`, `P12_7:Menciona` = Tipos de páginas de Internet desde las que se ha seguido la información de las elecciones autonómicas del País Vasco de 2020:
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P12_7'])
```
 + `P15_GRUPO:No` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P15'])
```
 + `P16:No` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P16'])
```
 + `P17_1_GRUPO:Casi nunca o nunca`, `P17_2_GRUPO:Casi nunca o nunca` = Frecuencia con la que se ha hablado en diferentes entornos sociales de las elecciones autonómicas del País Vasco de 2020: 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P17_1', 'P17_2')], collapse = ", "))
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P17_2_GRUPO)[4])
```
 + `P18_GRUPO:No` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P18')], collapse = ", "))
```
 + `P21_GRUPO:No quiso ir a votar` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P21')], collapse = ", "))
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P21_GRUPO)[2])
```
 + `P21A_GRUPO:Lo tenía decidido hace bastante tiempo (antes del inicio de la campaña electoral) `
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P21A')], collapse = ", "))
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P21A_GRUPO)[2])
```
 + `P23_GRUPO:Se habría abstenido o habría votado en blanco `
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P23')], collapse = ", "))
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P23_GRUPO)[2])
```
 + `P24_2_GRUPO:0 Con toda seguridad, no lo votaría nunca`, `P24_3_GRUPO:NS_NC`, `P24_4_GRUPO:0 Con toda seguridad, no lo votaría nunca`, `P24_5_GRUPO:NS_NC` = Escala de probabilidad (0-10) de votar a diferentes partidos políticos en las elecciones autonómicas del País Vasco:
    +
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P24_2')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_2_GRUPO)[1])
```
    +
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P24_3')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_3_GRUPO)[11])
```
    +
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P24_4')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_4_GRUPO)[1])
```
    +
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P24_5')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_5_GRUPO)[6])
```
 + `P26_2_GRUPO:No conoce` = Conocimiento y escala de valoración (1-10) de líderes políticos autonómicos del País Vasco
    +
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P26_2')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P26_2_GRUPO)[10])
```

En resumen: Este eje lado del eje representa a las personas que no les interesa la campaña electoral, ni la política, que nunca votarían a EH Bildu.

En el **lado negativo del eje** están las "variables:modalidades":

```{r}
# Show negative categories
aux_idx <- which(aux_tbl$k < 0)[1:n_categories_k_negative]
require(pander)

pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_negative, " modalidades más significativas del eje negativo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```

```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k < 0)], n = n_categories_k_negative))
cat(paste0("`", str_aux_1, "`", collapse = ", "), ".", sep = "")
```

Para explicar el significado de un eje, hay que ver la contribución (`ctr`) de cada modalidad dentro de esa parte del eje. A continuación se explican las modalidades más significativa de este lado del eje en orden de preguntas (no por su contribución):

 + `P6_GRUPO:Mucho` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P6'])
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P6_GRUPO)[1])
```
 + `P7_GRUPO:Con mucho interés` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P7'])
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P7_GRUPO)[1])
```
 + `P9A_GRUPO:Elkarrekin Berdeak` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P9A'])
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P9A_GRUPO)[8])
```
 + `P10B_GRUPO:Editoriales izquierda`, `P10DIGITAL:Menciona`
```{r echo=FALSE, results='asis'}
paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P10B', 'P10DIGITAL')], collapse = " / ")
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P10B_GRUPO)[3])
```
 + `P11_3:Menciona` = Redes sociales en Internet en las que se tiene cuenta: 
```{r echo=FALSE, results='asis'}
paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P11_3')], collapse = " / ")
```
 + `P12_1:Menciona`, `P12_5:Menciona` = Tipos de páginas de Internet desde las que se ha seguido la información de las elecciones autonómicas del País Vasco de 2020: 
```{r echo=FALSE, results='asis'}
paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P12_1', 'P12_5')], collapse = " / ")
```
 + `P15_GRUPO:Sí` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P15'])
```
 + `P15A_1:No menciona`, `P15A_11:Menciona`, `P15A_11:No menciona`, `P15A_12:Menciona`, `P15A_12:No menciona`, `P15A_18:No menciona`, `P15A_2:No menciona`, `P15A_21:Menciona`, `P15A_21:No menciona`, `P15A_95:No menciona`, `P15A_98:No menciona` = Ha enviado mensajes de:
```{r echo=FALSE, results='asis'}
# levels(cis_2020_acm_EB_df$P20)
cat(paste(levels(cis_2020_acm_EB_df$P20)[c(P20_idx_11_pnv, P20_idx_12_bildu, P20_idx_21_podem)], collapse = ", "))
```
 + `P16:Sí` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P16'])
```
 + `P16A_1:No menciona`, `P16A_11:Menciona`, `P16A_11:No menciona`, `P16A_12:Menciona`, `P16A_12:No menciona`, `P16A_18:No menciona`, `P16A_2:No menciona`, `P16A_21:Menciona`, `P16A_21:No menciona`, `P16A_95:No menciona`, `P16A_98:No menciona` = Ha recibido mensajes de:
```{r echo=FALSE, results='asis'}
# levels(cis_2020_acm_EB_df$P20)
cat(paste(levels(cis_2020_acm_EB_df$P20)[c(P20_idx_11_pnv, P20_idx_12_bildu, P20_idx_21_podem)], collapse = ", "))
```
 + `P17_1_GRUPO:Habitualmente`, `P17_2_GRUPO:Habitualmente` = 
Las elecciones fueron tema de conversación 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P17_1', 'P17_2')], collapse = ", "))
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P17_2_GRUPO)[1])
```

 + `P19ACOM_GRUPO:EH Bildu/Elkarrekin Podemos`
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P19ACOM')], collapse = ", "))
```
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P19ACOM_GRUPO)[12])
```

En resumen: son personas que envían y reciben mensajes relacionados con la política y están interesados en la política "nacionalista" y/o de izquierdas.


**Necesito una interpretación *certera* del significado de este eje por parte de JRB:**

En resumen: Este eje representa a las personas que por un extremo no les interesa la campaña electoral, ni la política, que nunca votarían a EH Bildu y por el otro les interesa la política.


## Dimensión 2

```{r}
i <- 2
# We want to show positive and negative categories of this dimension. And it is possible that only one side explains the wanted percentage, so we have to take extra categories from the other side to show.
# table with big percentage of eigenvalue
aux_tbl <- factor_categories(cis_2020_ca_opi01_factor, i, percet_eigenvalue)


# Select number of positive categories of table
n_categories_k_positive <- ifelse(length(which(aux_tbl$k > 0)) < num_categories_to_show, length(which(aux_tbl$k > 0)), num_categories_to_show)
# Select number of positive categories of table
n_categories_k_negative <- ifelse(length(which(aux_tbl$k < 0)) < num_categories_to_show, length(which(aux_tbl$k < 0)), num_categories_to_show)
```

En el **lado positivo del eje** las modalidades mejor representadas son:

```{r}
# Show positive categories
aux_idx <- which(aux_tbl$k > 0)[1:n_categories_k_positive]

require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_positive, " modalidades más significativas del eje positivo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```
```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k > 0)], n = n_categories_k_positive))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```

Para explicar el significado de un eje, hay que ver la contribución (`ctr`) de cada modalidad dentro de esa parte del eje. A continuación se explican las modalidades más significativa de este lado del eje en orden de preguntas (no por su contribución):

  + `ESCIDEOLPAR_1_GRUPO:NS_NC`, `ESCIDEOLPAR_2_GRUPO:NS_NC`, `ESCIDEOLPAR_3_GRUPO:NS_NC`, `ESCIDEOLPAR_4_GRUPO:NS_NC`, `ESCIDEOLPAR_5_GRUPO:NS_NC`, `ESCIDEOLPAR_6_GRUPO:NS_NC`, `ESCIDEOLPAR_7_GRUPO:NS_NC` = Escala de ubicación ideológica (1-10) de partidos políticos de la comunidad autónoma: No saben o no contestan.
  + `CLASESOCIAL_GRUPO:Clase pobre-` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'CLASESOCIAL'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$CLASESOCIAL_GRUPO)[5])
```
  + `ESCIDEOL_GRUPO:N.S.`
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'ESCIDEOL'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$ESCIDEOL_GRUPO)[8])
```
  + `P4_GRUPO:NS_NC` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P4')], collapse = " / "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P4_GRUPO)[5])
```
  + `P15_GRUPO:Sí`
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P15'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P15)[1])
```
  + `P15A_1:No menciona`, `P15A_11:Menciona`, `P15A_11:No menciona`, `P15A_12:Menciona`, `P15A_12:No menciona`, `P15A_18:Menciona`, `P15A_18:No menciona`, `P15A_2:Menciona`, `P15A_2:No menciona`, `P15A_21:Menciona`, `P15A_95:No menciona`, `P15A_98:No menciona` =
    + Los mensajes enviados no está claro de qué partido son.

  + `P16:Sí`
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P16'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P15)[1])
```
    + `P16A_21:Menciona`, `P16A_95:No menciona`, `P16A_98:No menciona` = 
```{r echo=FALSE, results='asis'}
# levels(cis_2020_acm_EB_df$P20)
cat(paste(levels(cis_2020_acm_EB_df$P20)[c(P20_idx_21_podem)], collapse = ", "))
```

  + `P24_1_GRUPO:NS_NC`, `P24_2_GRUPO:NS_NC`, `P24_3_GRUPO:NS_NC`, `P24_4_GRUPO:NS_NC`, `P24_5_GRUPO:NS_NC`, `P24_6_GRUPO:NS_NC`, `P24_7_GRUPO:NS_NC` = Escala de probabilidad (0-10) de votar a diferentes partidos políticos en las elecciones autonómicas del País Vasco: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_1_GRUPO)[11])
```
  + `P26_1_GRUPO:No conoce` = Conocimiento y escala de valoración (1-10) de líderes políticos autonómicos del País Vasco
    +
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P26_1')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P26_1_GRUPO)[10])
```


No sabe o no contesta a qué partido votar, no sabe o no contesta la escala ideológica  de varios partidos, sí envía mensajes electrónicos de ciertos partidos.

En el **lado negativo del eje** están las "variables:modalidades":

```{r}
# Show negative categories
aux_idx <- which(aux_tbl$k < 0)[1:n_categories_k_negative]
require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_negative, " modalidades más significativas del eje negativo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```

```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k < 0)], n = n_categories_k_negative))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
# TODO:  COMPROBAR QUE EN ESTA DIMENSION NEGATIVA (i=2) NO FALTAN MODALIDADES QUE EXPLICAR
```
 + `ESCIDEOL_GRUPO:3` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('ESCIDEOL')], collapse = " / "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$ESCIDEOL_GRUPO)[3])
```
 + `P5_GRUPO:Socialdemocracia` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P5')], collapse = " / "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P5_GRUPO)[2])
```
 + `P6_GRUPO:Poco` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P6')], collapse = " / "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P6_GRUPO)[3])
``` 
 + `P8_1_GRUPO:Poco`, `P8_2_GRUPO:Poco`, `P8_4_GRUPO:Poco` = Grado de utilidad de la campaña electoral de las elecciones autonómicas del País Vasco de 2020 en diferentes aspectos de la decisión de voto
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P8_1', 'P8_2', 'P8_4')], collapse = " / "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P8_1_GRUPO)[3])
``` 
 + `P10RADIO:Menciona`, `P10IMPRESA:Menciona`, `P10TV:Menciona` = Fuentes utilizadas para informarse sobre las elecciones autonómicas del País Vasco de 2020
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P10RADIO', 'P10IMPRESA', 'P10TV')], collapse = " / "))
```
 + `P10D_GRUPO:Estatales centro-izquierda` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P10D'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P10D_GRUPO)[3])
```
 + `P10A_GRUPO:Editoriales centro-derecha` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P10A'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P10A_GRUPO)[1])
```
 + `P10C_GRUPO:TV vascas públicas` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P10C'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P10C_GRUPO)[5])
```
 + `P10_2:Radio` = Fuentes utilizadas para informarse sobre las elecciones autonómicas del País Vasco de 2020, 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P10_2'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P10_2)[4])
```
 + `P11_2:No menciona`, `P11_7:Menciona` = Redes sociales en Internet en las que se tiene cuenta: 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P11_1', 'P11_7')], collapse = " / "))
```
 + `P12_5:No menciona` = Tipos de páginas de Internet desde las que se ha seguido la información de las elecciones autonómicas del País Vasco de 2020: No ha seguido 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P12_5')], collapse = " / "))
```
 + `P15_GRUPO:No` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P15'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P15)[2])
```
 + `P16:No` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P16'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P15)[2])
```
 + `P21_GRUPO:Normalmente vota, pero esta vez no quiso hacerlo` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P21'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P21)[3])
```
 + `P28_GRUPO:Me siento más vasco/a que español/a ` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P28'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P28_GRUPO)[4])
```
 
No recibe ni envía mensajes electrónicos. Se informó a través de prensa impresa, radio y TV. No sigue la campaña en redes sociales. Se siente más vasco que español. Se siente socialdemócrata.

**Necesito una interpretación *certera* del significado de este eje por parte de JRB. A falta de esa interpretación diremos que:** 

Este eje representa a las personas que envían mensajes electrónicos y dicen que no saben a quién votar y en el lado negativo del eje a los que no envían mensajes ni siguen redes sociales y se sienten socialdemócratas.

## Dimensión 3

```{r}
i <- 3
# We want to show positive and negative categories of this dimension. And it is possible that only one side explains the wanted percentage, so we have to take extra categories from the other side to show.
# table with big percentage of eigenvalue
aux_tbl <- factor_categories(cis_2020_ca_opi01_factor, i, percet_eigenvalue)


# Select number of positive categories of table
n_categories_k_positive <- ifelse(length(which(aux_tbl$k > 0)) < num_categories_to_show, length(which(aux_tbl$k > 0)), num_categories_to_show)
# Select number of positive categories of table
n_categories_k_negative <- ifelse(length(which(aux_tbl$k < 0)) < num_categories_to_show, length(which(aux_tbl$k < 0)), num_categories_to_show)
```

En el **lado positivo del eje** las modalidades mejor representadas son:

```{r}
# Show positive categories
aux_idx <- which(aux_tbl$k > 0)[1:n_categories_k_positive]

require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_positive, " modalidades más significativas del eje positivo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```
```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k > 0)], n = n_categories_k_positive))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```

Para explicar el significado de un eje, hay que ver la contribución (`ctr`) de cada modalidad dentro de esa parte del eje. A continuación se explican las modalidades más significativa de este lado del eje en orden de preguntas (no por su contribución):

  + `P9A_GRUPO:Conservador` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P9A'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P9A_GRUPO)[1])
```
  + `P14_GRUPO:Sí` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P14'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P14_GRUPO)[1])
```

    + `P14A_1:Menciona`, `P14A_11:Menciona`, `P14A_12:Menciona`, `P14A_18:Menciona`, `P14A_2:Menciona`, `P14A_21:Menciona`
    + `P14A_1:No menciona`, `P14A_11:No menciona`, `P14A_12:No menciona`, `P14A_18:No menciona`, `P14A_2:No menciona`, `P14A_21:No menciona`, `P14A_95:No menciona`, `P14A_98:No menciona` = Pero no queda claro por quienes fue contactado.
  + `P21_GRUPO:No quiso ir a votar`, `P21_GRUPO:Normalmente vota, pero esta vez no quiso hacerlo` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P21'])
```
: 
```{r echo=FALSE, results='asis'}
cat(paste(levels(cis_2020_acm_EB_df$P21_GRUPO)[c(2,3)], collapse = " / "))
```

  + `P21A_GRUPO:Lo tenía decidido hace bastante tiempo (antes del inicio de la campaña electoral) ` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P21A'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P21A_GRUPO)[2])
```
  + `P21B` = Razones para no ir a votar en las elecciones autonómicas del País Vasco de 2020:
    + `P21B_1_GRUPO:No había ninguna alternativa que le satisficiera`, `P21B_1_GRUPO:No le inspiraba confianza ningún partido ni ningún/a político/a` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P21B_1'])
```
: 
```{r echo=FALSE, results='asis'}
cat(paste(levels(cis_2020_acm_EB_df$P21B_1_GRUPO)[c(1,5)], collapse = " / "))
```
    + `P21B_2:Da lo mismo votar que no votar, no sirve para nada` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P21B_2'])
```
: 
```{r echo=FALSE, results='asis'}
cat(paste(levels(cis_2020_acm_EB_df$P21B_2)[3], collapse = " / "))
```

  + `P23_GRUPO:Se habría abstenido o habría votado en blanco ` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P23'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P23)[2])
```
  + `P24_2_GRUPO:0 Con toda seguridad, no lo votaría nunca`, `P24_4_GRUPO:0 Con toda seguridad, no lo votaría nunca`, `P24_7_GRUPO:2_10` = Escala de probabilidad (0-10) de votar a diferentes partidos políticos en las elecciones autonómicas del País Vasco :
    +
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P24_2'])
```  
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_2_GRUPO)[1])
```
    +
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P24_4'])
```  
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_2_GRUPO)[1])
```
    +
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P24_7'])
```  
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_7_GRUPO)[3])
```
  + `P26_1_GRUPO:1 Muy mal`, `P26_2_GRUPO:1 Muy mal`, `P26_3_GRUPO:1 Muy mal`, `P26_4_GRUPO:1 Muy mal` = Conocimiento y escala de valoración (1-10) de líderes políticos autonómicos del País Vasco
    +
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P26_1', 'P26_2', 'P26_3', 'P26_4')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P26_1_GRUPO)[1])
```
  + `P29_GRUPO:1 Mínimo grado de nacionalismo vasco` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P29')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P29_GRUPO)[1])
``` 

El lado positivo de esta dimensión puede representar a las personas se sienten conservadores, que fueron contactadas por algún partido, pero que no está claro por cual o cuales. Dicen que no descartan votar a "Vox" aunque saben que no votarían a "EH Bildu" ni  a "Elkarrekin Podemos". Se sienten no nacionalistas.

En el **lado negativo del eje** están las "variables:modalidades":

```{r}
# Show negative categories
aux_idx <- which(aux_tbl$k < 0)[1:n_categories_k_negative]
require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_negative, " modalidades más significativas del eje negativo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```

```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k < 0)], n = n_categories_k_negative))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```

 + `ESCIDEOL_GRUPO:N.S.` = 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('ESCIDEOL')], collapse = " / "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$ESCIDEOL_GRUPO)[9])
```

 + `ESCIDEOLPAR_1_GRUPO:NS_NC`, `ESCIDEOLPAR_2_GRUPO:NS_NC`, `ESCIDEOLPAR_3_GRUPO:NS_NC`, `ESCIDEOLPAR_4_GRUPO:NS_NC`, `ESCIDEOLPAR_5_GRUPO:NS_NC`, `ESCIDEOLPAR_6_GRUPO:NS_NC`, `ESCIDEOLPAR_7_GRUPO:NS_NC`  =  No sabe o no contesta sobre la escala ideológica de ningún partido.
 + `CLASESOCIAL_GRUPO:Clase pobre-` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'CLASESOCIAL'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$CLASESOCIAL_GRUPO)[5])
```
 + `P8_4_GRUPO:Poco` = Grado de utilidad de la campaña electoral de las elecciones autonómicas del País Vasco de 2020 en diferentes aspectos de la decisión de voto
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P8_4')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P8_4_GRUPO)[3])
```
 + `P10C_GRUPO:TV vascas públicas` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P10C'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P10C_GRUPO)[5])
```

 + `P10_2:Televisión` = Fuentes utilizadas para informarse sobre las elecciones autonómicas del País Vasco de 2020, 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P10_2'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P10_2)[4])
```
 + `P11_7:Menciona` = Redes sociales en Internet en las que se tiene cuenta: 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P11_7')], collapse = " / "))
```
 + `P12_9:Menciona` = Tipos de páginas de Internet desde las que se ha seguido la información de las elecciones autonómicas del País Vasco de 2020: 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P12_9')], collapse = " / "))
```
 + `P14_GRUPO:No` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P14'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P14_GRUPO)[2])
```

 + `P16:No` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P16'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P15)[2])
```
 + `P19A02_GRUPO:Elkarrekin Podemos` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P19A02'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P19A02_GRUPO)[6])
```
 + `P20A`, Razones para votar al partido político votado en las elecciones autonómicas del País Vasco de 2020:
   + `P20A_1_GRUPO:Porque es el que mejor representa las ideas de la gente como Ud.` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P20A_1'])
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P20A_1_GRUPO)[4])
```
   + `P20A_2:N.C.`, `P20A_2:Por el/la candidato/a que presentaba a lehendakari` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P20A_2'])
```
: 
```{r echo=FALSE, results='asis'}
cat(paste(levels(cis_2020_acm_EB_df$P20A_2)[c(9, 1)], collapse = " / "))
```
 + `P22_GRUPO:Lo decidió durante la última semana de la campaña electoral, unos días antes de las elecciones ` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P22'])
```
: 
```{r echo=FALSE, results='asis'}
cat(paste(levels(cis_2020_acm_EB_df$P22_GRUPO)[3], collapse = " / "))
```
 + `P23_GRUPO:Habría votado por el mismo partido o coalición por el que lo hizo ` = 
```{r echo=FALSE, results='asis'}
cat(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) == 'P23'])
```
: 
```{r echo=FALSE, results='asis'}
cat(paste(levels(cis_2020_acm_EB_df$P23_GRUPO)[1], collapse = " / "))
```
 + `P24_1_GRUPO:8`, `P24_1_GRUPO:NS_NC`, `P24_2_GRUPO:NS_NC`, `P24_3_GRUPO:NS_NC`, `P24_4_GRUPO:NS_NC`, `P24_5_GRUPO:NS_NC`, `P24_6_GRUPO:NS_NC`, `P24_7_GRUPO:NS_NC` = Escala de probabilidad (0-10) de votar a diferentes partidos políticos en las elecciones autonómicas del País Vasco: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P24_1_GRUPO)[11])
```
 + `P26_1_GRUPO:No conoce`, `P26_2_GRUPO:7` = Conocimiento y escala de valoración (1-10) de líderes políticos autonómicos del País Vasco
    + 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P26_1')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P26_1_GRUPO)[10])
```
    + 
```{r echo=FALSE, results='asis'}
cat(paste(attributes(cis_2020_acm_EB_df)$variable.labels[colnames(cis_2020_acm_EB_df) %in% c('P26_2')], collapse = ", "))
```
: 
```{r echo=FALSE, results='asis'}
cat(levels(cis_2020_acm_EB_df$P26_1_GRUPO)[7])
```

El lado negativo de esta dimensión contiene a las personas que: dicen no conocer la escala ideológica de ningún partido dicen; que deciden el voto en la última semana de campaña; se reconoce como de clase "Pobre"; y en 2020 dudó si votar o no a "Elkarrekin-Podemos".
 

En resumen: Este eje representa a las personas que se manifiestan  conservadoras y centralistas y en el lado negativo del eje a los que no saben o no contestan a quien votar, se sienten pobres y votaron a un partido nacionalista.

**Necesito una interpretación *certera* del significado de este eje por parte de JRB.** 

## Dimensión 4

Se muestran las tablas con las variables más representativas de esta dimensión:

```{r}
i <- 4
# We want to show positive and negative categories of this dimension. And it is possible that only one side explains the wanted percentage, so we have to take extra categories from the other side to show.
# table with big percentage of eigenvalue
aux_tbl <- factor_categories(cis_2020_ca_opi01_factor, i, percet_eigenvalue)


# Select number of positive categories of table
n_categories_k_positive <- ifelse(length(which(aux_tbl$k > 0)) < num_categories_to_show, length(which(aux_tbl$k > 0)), num_categories_to_show)
# Select number of positive categories of table
n_categories_k_negative <- ifelse(length(which(aux_tbl$k < 0)) < num_categories_to_show, length(which(aux_tbl$k < 0)), num_categories_to_show)
```

En el **lado positivo del eje** las modalidades mejor representadas son:

```{r}
# Show positive categories
aux_idx <- which(aux_tbl$k > 0)[1:n_categories_k_positive]

require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_positive, " modalidades más significativas del eje positivo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```
```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k > 0)], n = n_categories_k_positive))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```

En el **lado negativo del eje** están las "variables:modalidades":

```{r}
# Show negative categories
aux_idx <- which(aux_tbl$k < 0)[1:n_categories_k_negative]
require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_negative, " modalidades más significativas del eje negativo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```

```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k < 0)], n = n_categories_k_negative))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```


## Dimensión 5

Se muestran las tablas con las variables más representativas de esta dimensión:

```{r}
i <- 5
# We want to show positive and negative categories of this dimension. And it is possible that only one side explains the wanted percentage, so we have to take extra categories from the other side to show.
# table with big percentage of eigenvalue
aux_tbl <- factor_categories(cis_2020_ca_opi01_factor, i, percet_eigenvalue)


# Select number of positive categories of table
n_categories_k_positive <- ifelse(length(which(aux_tbl$k > 0)) < num_categories_to_show, length(which(aux_tbl$k > 0)), num_categories_to_show)
# Select number of positive categories of table
n_categories_k_negative <- ifelse(length(which(aux_tbl$k < 0)) < num_categories_to_show, length(which(aux_tbl$k < 0)), num_categories_to_show)
```

En el **lado positivo del eje** las modalidades mejor representadas son:

```{r}
# Show positive categories
aux_idx <- which(aux_tbl$k > 0)[1:n_categories_k_positive]

require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_positive, " modalidades más significativas del eje positivo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```
```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k > 0)], n = n_categories_k_positive))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```

En el **lado negativo del eje** están las "variables:modalidades":

```{r}
# Show negative categories
aux_idx <- which(aux_tbl$k < 0)[1:n_categories_k_negative]
require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_negative, " modalidades más significativas del eje negativo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```

```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k < 0)], n = n_categories_k_negative))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```


## Dimensión 6

Se muestran las tablas con las variables más representativas de esta dimensión:

```{r}
i <- 6
# We want to show positive and negative categories of this dimension. And it is possible that only one side explains the wanted percentage, so we have to take extra categories from the other side to show.
# table with big percentage of eigenvalue
aux_tbl <- factor_categories(cis_2020_ca_opi01_factor, i, percet_eigenvalue)


# Select number of positive categories of table
n_categories_k_positive <- ifelse(length(which(aux_tbl$k > 0)) < num_categories_to_show, length(which(aux_tbl$k > 0)), num_categories_to_show)
# Select number of positive categories of table
n_categories_k_negative <- ifelse(length(which(aux_tbl$k < 0)) < num_categories_to_show, length(which(aux_tbl$k < 0)), num_categories_to_show)
```

En el **lado positivo del eje** las modalidades mejor representadas son:

```{r}
# Show positive categories
aux_idx <- which(aux_tbl$k > 0)[1:n_categories_k_positive]

require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_positive, " modalidades más significativas del eje positivo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```
```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k > 0)], n = n_categories_k_positive))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```

En el **lado negativo del eje** están las "variables:modalidades":

```{r}
# Show negative categories
aux_idx <- which(aux_tbl$k < 0)[1:n_categories_k_negative]
require(pander)
pander(aux_tbl[aux_idx,], caption = paste0("Dimensión ", i, ". Contiene las ", n_categories_k_negative, " modalidades más significativas del eje negativo que abarcan el ", round(100 * sum(aux_tbl$ctr[aux_idx])/sum(cis_2020_ca_opi01_factor[,paste0("ctr",i)], na.rm = TRUE)), " % de la dimensión."))
```

```{r eval=FALSE, include=FALSE, echo=FALSE}
str_aux_1 <- sort(head(aux_tbl$`Variable:modalidad`[which(aux_tbl$k < 0)], n = n_categories_k_negative))
cat(paste0("`", str_aux_1, "`", collapse = ", "), sep = "")
```






```{r}
# plot(ACM_coches)
# plot(ACM_coches, mass = c(FALSE, TRUE))
# plot(ACM_coches, mass = c(FALSE, TRUE), contrib="absolute")

gg_plot_MCA_cols <- function(dimX = 1, dimY = 2, coord_type = "standard"){

  require(ca)
  # Extracting coordinates from mjca objects
  # type = c("standard", "principal", "symmetric", "rowprincipal", "colprincipal", "symbiplot", "rowgab", "colgab", "rowgreen", "colgreen")
  aux_coord <- ca::cacoord(cis_2020_ca_opi01, type = coord_type, dim = c(dimX, dimY), cols = TRUE, rows = FALSE)
  # dataframe with dimensions coordinates
  my_title <- "Variables activas en el plano factorial"
  col_coord_df <- cbind.data.frame(aux_coord[,1],
                                 aux_coord[,2],
                               cis_2020_ca_opi01$levelnames)

  colnames(col_coord_df) <- c("dimX", "dimY", "name")

  require(ggplot2)
  require(ggrepel)
  # Se crea el objeto con el grafico
  ggplot(col_coord_df, aes(x=col_coord_df$dimX, y=col_coord_df$dimY)) +
    geom_point() + geom_rug() +
    # xlim(-2.6, 3.5) + ylim(-2.1,3.8)+
    geom_text_repel(aes(label=col_coord_df$name),hjust=0, vjust=0,size=3.3) +
    scale_colour_brewer(palette = "Set1") +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) + 
    ggtitle(my_title) +
    xlab(paste("Dimension ", dimX, " (", round(100 * cis_2020_ca_opi01$inertia.e[dimX], digits = 1) , "% )", sep = "")) +
    ylab(paste("Dimension ", dimY, " (", round(100 * cis_2020_ca_opi01$inertia.e[dimY], digits = 1) , "% )", sep = ""))
}
```



```{r plot_MCA_cols}
gg_plot_MCA_cols(dimX = 1, dimY = 2)
gg_plot_MCA_cols(dimX = 2, dimY = 3)
gg_plot_MCA_cols(dimX = 3, dimY = 4)
gg_plot_MCA_cols(dimX = 4, dimY = 5)
gg_plot_MCA_cols(dimX = 5, dimY = 6)
```


# Individuos
```{r}
gg_plot_MCA_rows <- function(dimX = 1, dimY = 2, coord_type = "standard"){
  require(ca)
  # Extracting principal from mjca objects
  # type = c("standard", "principal", "symmetric", "rowprincipal", "colprincipal", "symbiplot", "rowgab", "colgab", "rowgreen", "colgreen")
  aux_coord <- ca::cacoord(cis_2020_ca_opi01, type = coord_type, dim = c(dimX, dimY), cols = FALSE, rows = TRUE)
  # dataframe with dimensions coordinates
  my_title <- "Individuos en el plano factorial"
  row_coord_df <- cbind.data.frame(aux_coord[,1],
                                 aux_coord[,2],
                                 # 1:nrow(aux_coord),
                                 rownames(cis_2020_acm_EB_df),
                                 cis_2020_acm_EB_df$P20_GRUPO)
  
  colnames(row_coord_df) <- c("dimX", "dimY", "name", "P20_GRUPO")

  require(ggplot2)
  require(ggrepel)
  # Se crea el objeto con el grafico
  ggplot(row_coord_df, aes(x=row_coord_df$dimX, y=row_coord_df$dimY, color=P20_GRUPO)) +
    geom_point() + geom_rug() +
    # xlim(-2.6, 3.5) + ylim(-2.1,3.8)+
    geom_text_repel(aes(label=row_coord_df$name),hjust=0, vjust=0,size=3.3) +
    # scale_colour_brewer(palette = "Set1") +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) + 
    ggtitle(my_title) +
    xlab(paste("Dimension ", dimX, " (", round(100 * cis_2020_ca_opi01$inertia.e[dimX], digits = 1) , "% )", sep = "")) +
    ylab(paste("Dimension ", dimY, " (", round(100 * cis_2020_ca_opi01$inertia.e[dimY], digits = 1) , "% )", sep = "")) +
    # levels(cis_2020_acm_EB_df$P20_GRUPO)
    scale_color_manual(breaks = c("Conservador", "Elkarrekin Podemos", "Berdeak", "PACMA", "Resto", "Abstención+"),
                        values=c("cyan", "magenta", "darkgreen", "navajowhite3", "navajowhite", "yellow"))
}
```


A continuación se muestran a los individuos en diferentes planos factoriales.

```{r plot_MCA_rows}
gg_plot_MCA_rows(dimX = 1, dimY = 2)
gg_plot_MCA_rows(dimX = 2, dimY = 3)
gg_plot_MCA_rows(dimX = 3, dimY = 4)
gg_plot_MCA_rows(dimX = 4, dimY = 5)
gg_plot_MCA_rows(dimX = 5, dimY = 6)
```






## Decidir el número de cluster y caracterizar estos cluster.

```{r eval=FALSE}
### # Se seleccionan las variables que se van a utilizar
### cis_2020_acm_EB_df <- cis_2020_acm_EB_df
```

Se muestra la división cluster por el método *Ward.D* o también conocido como *"pérdida de inercia mínima"*.

```{r}
# Find rows coordinates in factorial space
# type = c("standard", "principal", "symmetric", "rowprincipal", "colprincipal", "symbiplot", "rowgab", "colgab", "rowgreen", "colgreen")
aux_tbl <- ca::cacoord(cis_2020_ca_opi01, type = "standard", dim = c(1:numDim), cols = FALSE, rows = TRUE)
# Append rows coordinates to data.frame
cis_2020_acm_EB_df <- cbind.data.frame(cis_2020_acm_EB_df, aux_tbl)

formula_all_dims <- as.formula(paste("~-1 +", paste0("Dim",1:numDim, collapse = "+")))
# Distancia euclidea al cuadrado entre los elementos de la matriz
dist_individuos <- stats::dist(model.matrix(formula_all_dims, cis_2020_acm_EB_df))^2
HClust.2 <- hclust(dist_individuos , method= "ward.D")

plot(HClust.2, main= "Cluster Dendrograma para individuos", xlab= 
  "Encuestas CIS EQUO", sub="Method=ward.D; Distancia=euclidea al cuadrado")
```

Parece que el número de cluster adecuado es XXXX a la vista de las alturas de las ramas del dendograma. Pero al igual que en el análisis de correspondencias simples, aquí  también se puede buscar el número óptimo de clusters (`k`) usando la función `daisy` (Dissimilarity Matrix Calculation) que computa las desigualdades en las distancias entre parejas. En este caso se ha usado la métrica euclídea al cuadrado para ese cálculo. Para obtener el número óptimo de clusters y su composición.

 
```{r}
# Funcion para calcular el k optimo
# Creamos una funcion para calcular la matriz de distancia dos a dos con los grupos
# daisy: Compute all the pairwise dissimilarities (distances) between observations in the data set.
grpdist <- function(X, metrica="gower"){
  # metrica = "euclidean", "gower"
  # Se carga la libreria "cluster"
  require(cluster)
  gr <- as.data.frame(as.factor(X))
  distgr <- daisy(gr, metrica)
  distgr
  }
```


```{r}
# Se selecciona el numero optimo de clusters
# data frame auxialiar
kt <- data.frame(k=1:nrow(cis_2020_acm_EB_df), r=0)

mtdo_usado = "ward.D"
HClust_aux <- hclust(dist_individuos , method= mtdo_usado)

for(i in 2:(nrow(cis_2020_acm_EB_df)-1)){
  gr <- cutree(HClust_aux, i)
  distgr <- grpdist(gr, "gower")
  # distgr <- grpdist(gr, "euclidean")
  mt <- cor(dist_individuos, distgr, method="pearson")
  kt[i,2] <- mt
  }
# Calculamos mediante el estadístico de Mantel el número de clusters óptimo:
cat('\nMétodo: "', mtdo_usado,'". k óptimo = ',k.best <- which.max(kt$r),'\nComposición de los clusters:\n', sep = "")

print(summary(as.factor(cutree(HClust_aux, k = k.best))))

```


```{r include=FALSE, eval=FALSE}

# Lista de metodos a testear
lista_mtdos = c("ward.D", "ward.D2", "complete", "single", "average", "mcquitty", "median", "centroid")
# data frame auxialiar
kt <- data.frame(k=1:nrow(cis_2020_acm_EB_df), r=0)

# Bucle para testear todos los metodos con la distancia elegida
for (mtdo_usado in lista_mtdos)
{
  HClust_aux <- hclust(dist_individuos , method= mtdo_usado)

  # plot(HClust_aux, main= "Cluster Dendrograma para coches", xlab= "Vehículos estudiados",sub=paste("Metodo=", mtdo_usado,"; Distancia=euclidea al cuadrado", sep = ""))

  for(i in 2:(nrow(cis_2020_acm_EB_df)-1)){
    gr <- cutree(HClust_aux, i)
    distgr <- grpdist(gr, "gower")
    mt <- cor(dist_individuos, distgr, method="pearson")
    kt[i,2] <- mt
    }
  # Calculamos mediante el estadístico de Mantel el número de clusters óptimo:
  cat('\nMétodo: "', mtdo_usado,'". k óptimo = ',k.best <- which.max(kt$r),'\nComposición de los clusters:\n', sep = "")

  print(summary(as.factor(cutree(HClust_aux, k = k.best))))
}
```



```{r}
require("RcmdrMisc")

# Funcion que genera el objeto con la figura
gg_plot_ACM <- function(hCluter_figura, dimX = 1, dimY = 2, k.optimo=3, titulo = "") {
  #hCluter_figura <- HClust.2

  # create column name
  C1 <- paste0("Dim", dimX)
  C2 <- paste0("Dim", dimY)

  # Se crea una columna con el numero de cluster asignado a ese coche
  cis_2020_acm_EB_df$num_cluster <- assignCluster(model.matrix(formula_all_dims, cis_2020_acm_EB_df), 
                                                    cis_2020_acm_EB_df, cutree(hCluter_figura, k = k.optimo))
  
  figura <- ggplot(data=cis_2020_acm_EB_df, aes(x=.data[[C1]], y=.data[[C2]], color=num_cluster)) +
    geom_point() + geom_rug() +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) +
    geom_text_repel(aes(label=rownames(cis_2020_acm_EB_df)),hjust=0, vjust=0, size=3.3) +
    #geom_text(aes(label=rownames(cis_2020_acm_EB_df)),hjust=0, vjust=0, size=3.3) +
    theme(legend.position="top") + ggtitle(titulo)
  
  return(figura)
}
```


```{r include=FALSE, eval=FALSE}
# Se buscan outliers
require("RcmdrMisc")

require(gridExtra)
require(grid)
require(ggplot2)
require(lattice)

# Método: "complete". k óptimo = 3
k_aux <-  k.best
HClust_aux <- hclust(dist_individuos , method= "complete")
# Se crea una columna con el numero de cluster asignado a ese coche
aux_tbl <- cis_2020_acm_EB_df[,-(1:(ncol(cis_2020_acm_EB_df)-numDim))]
aux_tbl$num_cluster <- assignCluster(model.matrix(formula_all_dims, aux_tbl), 
                                                  aux_tbl, cutree(HClust_aux, k = k_aux))

j <- c()
for (i in 1:k_aux) {
  j <- c(j, length(which(aux_tbl$num_cluster == i)))
  print(paste(i, length(which(aux_tbl$num_cluster == i))))
}
outlier_rows <- as.numeric(rownames(aux_tbl)[which(aux_tbl$num_cluster %in% which.min(j))])
# Outlier rows: 86 751 1393 1412 2343
cat("Outlier rows:", outlier_rows)


g1grob <- ggplotGrob(gg_plot_ACM(HClust_aux, k.optimo = k_aux, titulo = paste("Método complete", k_aux, "clusters")))
# Se crea el texto que se mostrara con la figura
# Distribución de los vehículos en cada cluster:
txt_distrib_clusters <- "Composición de los clusters: "
distrib_clusters <-  summary(as.factor(cutree(HClust_aux, k = k_aux)))
for (i in 1:k_aux){
  txt_distrib_clusters <- paste(txt_distrib_clusters, distrib_clusters[i] )
}
texto1 <- textGrob(txt_distrib_clusters, gp=gpar(fontsize=10))




# Se muestran la figuras
grid.arrange(
  grobs = list(g1grob, texto1),
  heights = c(9, 1),
  layout_matrix = rbind(c(1, 2),
                        c(3, 4))
)

```



```{r include=FALSE, eval=FALSE}
# Se generan particiones de prueba de 3  y 4 clusters
require("RcmdrMisc")

require(gridExtra)
require(grid)
require(ggplot2)
require(lattice)

# Método: "ward.D". k óptimo = 3
k_aux <-  k.best
HClust_aux <- hclust(dist_individuos , method= "ward.D")
g1grob <- ggplotGrob(gg_plot_ACM(HClust_aux, k.optimo = k_aux, titulo = paste("Método ward.D.", k_aux, "clusters")))
# Se crea el texto que se mostrara con la figura
# Distribución de los vehículos en cada cluster:
txt_distrib_clusters <- "Composición de los clusters: "
distrib_clusters <-  summary(as.factor(cutree(HClust.2, k = k_aux)))
for (i in 1:k_aux){
  txt_distrib_clusters <- paste(txt_distrib_clusters, distrib_clusters[i] )
}
texto1 <- textGrob(txt_distrib_clusters, gp=gpar(fontsize=10))


# Método: "ward.D". k óptimo = 4
k_aux = 6
HClust_aux <- hclust(dist_individuos , method= "ward.D")
g2grob <- ggplotGrob(gg_plot_ACM(HClust_aux, k.optimo = k_aux, titulo = paste("Método ward.D.", k_aux, "clusters")))
# Se crea el texto que se mostrara con la figura
# Distribución de los vehículos en cada cluster:
txt_distrib_clusters <- "Composición de los clusters: "
distrib_clusters <-  summary(as.factor(cutree(HClust.2, k = k_aux)))
for (i in 1:k_aux){
  txt_distrib_clusters <- paste(txt_distrib_clusters, distrib_clusters[i] )
}
texto2=textGrob(txt_distrib_clusters, gp=gpar(fontsize=10))



# Se muestran la figuras
grid.arrange(
  grobs = list(g1grob, g2grob, texto1, texto2),
  heights = c(9, 1),
  layout_matrix = rbind(c(1, 2),
                        c(3, 4))
)

```


```{r}
# Se genera el cluster optimo y se representa en el plano
require(gridExtra)
require(grid)
require(ggplot2)
require(lattice)

# La matriz dist_individuos contiene las distancias eclideas al cuadrado.
#
# Se toma el metodo mas adecuado
mtdo_usado_acm = "ward.D"

library(cluster)
require(cluster)

# Se elige el numero de clusters optimo
for(i in 2:(nrow(cis_2020_acm_EB_df)-1)){
  gr <- cutree(HClust.2, i)
  distgr <- grpdist(gr, "gower")
  mt <- cor(dist_individuos, distgr, method="pearson")
  kt[i,2] <- mt
}

num_clusters_acm <- which.max(kt$r)

# Método: "ward.D". k óptimo = 3
HClust.2 <- hclust(dist_individuos , method = mtdo_usado_acm)

# Se crea la figuar
gg_cluster_ACM <- ggplotGrob(gg_plot_ACM(HClust.2, k.optimo = num_clusters_acm, titulo = paste("Método", mtdo_usado_acm)))

# Se crea el texto que se mostrara con la figura
# Distribución de los vehículos en cada cluster:
txt_distrib_clusters <- "Composición de los clusters: "
distrib_clusters <-  summary(as.factor(cutree(HClust.2, k = num_clusters_acm)))
for (i in 1:num_clusters_acm){
  txt_distrib_clusters <- paste(txt_distrib_clusters, distrib_clusters[i] )
}
texto1 <- textGrob(txt_distrib_clusters, gp=gpar(fontsize=10))

# Dendograma
require(factoextra)
gg_dendograma_ACM <- fviz_dend(HClust.2, k=num_clusters_acm,rect = T, show_labels = FALSE)

### grid.arrange(gg_cluster_ACM, gg_dendograma_ACM, ncol=2)

# Se muestran la figura
grid.arrange(
  grobs = list(gg_cluster_ACM, texto1, gg_dendograma_ACM),
  heights = c(9, 1),
  layout_matrix = rbind(c(1, 3),
                        c(2, 2))
)

```


RANN: Fast Nearest Neighbour Search (Wraps ANN Library) Using L2 Metric

```{r}
library(RANN)
require(RANN)
# Save individuals coordinates
individuals_space_df <- cis_2020_acm_EB_df[, c(paste0("Dim", 1:numDim))]

# Select individuals from "Berdeak" or "Otro partido"
# levels(cis_2020_acm_EB_df$P20_GRUPO)
EB_rows_b <- which(cis_2020_acm_EB_df$P20_GRUPO %in% "Berdeak")
# levels(cis_2020_acm_EB_df$RVAUTO20)
EB_rows_o <- which(cis_2020_acm_EB_df$RVAUTO20 %in% "Otro partido")
EB_rows <- unique(c(EB_rows_b, EB_rows_o))
# create dataframe with that group
EB_points_df <- individuals_space_df[EB_rows,]
# Nearest Neighbour Search
EB_points_neighb <- RANN::nn2(data = individuals_space_df, query = EB_points_df, k = 10)

# Put those groups in a vector
EB_points_neighb_idx <- c()
for(i in EB_points_neighb$nn.idx) {
  EB_points_neighb_idx <- c(EB_points_neighb_idx, i)
}
EB_points_neighb_idx <- unique(EB_points_neighb_idx)
# Select only neighbours
EB_points_neighb_idx <- EB_points_neighb_idx[!(EB_points_neighb_idx %in% EB_rows)]
# Create column with neighbours
# levels(cis_2020_acm_EB_df$RVAUTO20)
cis_2020_acm_EB_df$P20_NEIGH <- cis_2020_acm_EB_df$RVAUTO20

# Create new neighbours level and recode from "Otro partido" to "EQUO Berdeak"
aux_idx <- which(levels(cis_2020_acm_EB_df$P20_NEIGH) == 'Otro partido')
recodes_str <- sprintf("c(%s) = 'EQUO Berdeak'",
                       paste0("'", levels(cis_2020_acm_EB_df$P20_NEIGH)[aux_idx], "'", collapse = ", "))
neighbours_lbl <- 'Cercanos EB'
# Recode
cis_2020_acm_EB_df$P20_NEIGH_GRUPO <- car::recode(var = cis_2020_acm_EB_df$P20_NEIGH, 
                                    recodes = recodes_str,
                                    levels = c(levels(cis_2020_acm_EB_df$P20_NEIGH)[1:(aux_idx-1)], 'EQUO Berdeak', neighbours_lbl, levels(cis_2020_acm_EB_df$P20_NEIGH)[-(1:aux_idx)]))
# Rename neighbours
cis_2020_acm_EB_df$P20_NEIGH_GRUPO[EB_points_neighb_idx] <- neighbours_lbl #levels(cis_2020_acm_EB_df$P20_NEIGH_GRUPO)[aux_idx+1]

pander(cis_2020_acm_EB_df %>% dplyr::count(P20_NEIGH_GRUPO, .drop=FALSE), caption = "Votos en 2020 y vecinos cercanos a EQUO Berdeak")

pander(cis_2020_acm_EB_df %>% dplyr::count(RVAUTO20, .drop=FALSE), caption = "Votos en 2020")
```

```{r}
# Plot selected points a its neighbours
gg_plot_neighbours <- function(dimX = 1, dimY = 2){

  my_title <- "Individuos Cercanos a Equo-Berdeak en 2020"
  row_coord_df <- cbind.data.frame(cis_2020_acm_EB_df[,paste0("Dim",dimX)],
                                 cis_2020_acm_EB_df[,paste0("Dim",dimY)],
                                 rownames(cis_2020_acm_EB_df),
                                 cis_2020_acm_EB_df$P20_NEIGH_GRUPO)
  
  colnames(row_coord_df) <- c("dimX", "dimY", "name", "P20_NEIGH_GRUPO")

  require(ggplot2)
  require(ggrepel)
  # Se crea el objeto con el grafico
  gg_obj <- ggplot(row_coord_df, aes(x=dimX, y=dimY, color=P20_NEIGH_GRUPO)) +
    geom_point() + geom_rug() +
    # xlim(-2.6, 3.5) + ylim(-2.1,3.8)+
    geom_text_repel(aes(label=name),hjust=0, vjust=0,size=3.3, max.overlaps = 20) +
    # scale_colour_brewer(palette = "Set1") +
    geom_vline(xintercept = 0) + geom_hline(yintercept = 0) + 
    ggtitle(my_title) +
    xlab(paste("Dimension ", dimX, " (", round(100 * cis_2020_ca_opi01$inertia.e[dimX], digits = 1) , "% )", sep = "")) +
    ylab(paste("Dimension ", dimY, " (", round(100 * cis_2020_ca_opi01$inertia.e[dimY], digits = 1) , "% )", sep = "")) +
    # levels(cis_2020_acm_EB_df$P20_NEIGH_GRUPO)
    scale_color_manual(breaks = c("PP+C's", "PSE-EE-PSOE", 
                                  "EAJ-PNV", "EH Bildu", 
                                  "PACMA", "VOX", 
                                  "Elkarrekin Podemos", 
                                  "Voto nulo", "EQUO Berdeak", "Cercanos EB", 
                                  "En blanco", "No votó/abstención", "No recuerda", "N.C."),
                       values=c("cyan", "red", 
                                "navajowhite", "navajowhite",
                                "navajowhite3", "cyan", 
                                "magenta", 
                                "yellow", "darkgreen", "limegreen",
                                "yellow", "yellow", "yellow", "yellow"))
  
  return(gg_obj)
}
```

Se muestran a todos los vecinos de *EQUO Berdeak* en diferentes planos factoriales.

```{r plot_neigbours}
gg_plot_neighbours(dimX = 1, dimY = 2)
gg_plot_neighbours(dimX = 2, dimY = 3)
gg_plot_neighbours(dimX = 3, dimY = 4)
gg_plot_neighbours(dimX = 4, dimY = 5)
gg_plot_neighbours(dimX = 5, dimY = 6)
```







```{r}
log4r::info(logger,  paste(Sys.time(), 'Ending script'))
```



***

\pagebreak


---
