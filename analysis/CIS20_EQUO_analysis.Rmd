---
title: "CIS 2020 analisis EQUO"
subtitle: "Análisis de datos de encuestas de EQUO y Podemos"
author: "ImJaviPerez"
date: "Marzo 2023"
output:
  html_document:
    toc: yes
    toc_depth: '4'
    df_print: paged
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
header-includes:
- \usepackage{xcolor}
- \usepackage{framed}
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead[RO,RE]{AnálisiS parcial}
- \fancyfoot{}
- \fancyfoot[RE,LO]{Votos 2020}
- \fancyfoot[LE,RO]{\thepage}
bibliography: BibliografiaME.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE)

#    include = FALSE prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.
#    echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.
#    message = FALSE prevents messages that are generated by code from appearing in the finished file.
#    warning = FALSE prevents warnings that are generated by code from appearing in the finished.
#    fig.cap = "..." adds a caption to graphical results.
#    results='asis' = output as-is, i.e., write raw results from R into the output document
```


```{r include=FALSE}
# Borrar toda las variables
### rm(list=ls())
```

***
```{r}
# List of libraries
library(foreign)
library(dplyr)
library(pander)
library(car)
library(ca)
```

```{r}
library(log4r)
# Create a new logger object with create.logger().
logger <- create.logger()
# Set the logger's file output.
logfile(logger) <- 'cis_2020_analisis.log'
# Set the current level of the logger.
level(logger) <- "DEBUG"
#level(logger) <- "INFO"
# At priority level INFO, a call to debug() won't print anything.
# debug(logger, 'A Debugging Message')
info(logger,  paste(Sys.time(), 'Starting script'))
# warn(logger, 'A Warning Message')
# error(logger, 'An Error Message')
# fatal(logger, 'A Fatal Error Message')

```


```{r}
# TODO
# http://destio.us.es/calvo/asignaturas/ge_esco/tutorialusargitgithubrstudio/UsarGitGithubconRStudio.html
# Seguir indicaciones de JRB
```


\pagebreak

# Análisis de correspondencias múltiples
Datos cualitativos procedentes de encuestas realizadas por el  [Centro de Investigaciones Sociológicas (CIS)](https://www.cis.es) en septiembre de 2020:
[Encuesta 3293/0 POSTELECTORAL DEL PAÍS VASCO. ELECCIONES AUTONÓMICAS 2020](https://www.cis.es/cis/opencm/ES/1_encuestas/estudios/listaMuestras.jsp?estudio=14522).

# Descripción del fichero de datos.

Para conocer las preguntas consultar el fichero: "Estudio: Postelectoral Autonómicas País Vasco 2020 Clave: ECIS3293" del link mencionado anteriormente.


```{r}
# We have to filter CIS 2020 data previously. It spends a lot of time for it's calculations, thus we have made those calculations in an other script and now we load those results.
require(log4r)

cis_2020_cuisine_file <- file.path(getwd(), "cis_2020_equo_cuisine.RData")
if (file.exists(cis_2020_cuisine_file)) {
  load(cis_2020_cuisine_file)
  log4r::info(logger, paste("cis_2020_cuisine_file (", cis_2020_cuisine_file, ") exists =", file.exists(cis_2020_cuisine_file)))
}else{
  log4r::error(logger, paste("File", cis_2020_cuisine_file, "DO NOT EXISTS. You must create this file using the script Cuisine.Rmd"))
  stop(paste("File", cis_2020_cuisine_file, "DO NOT EXISTS. You must create this file using the script Cuisine.Rmd"))
}
```

Ahora, realizamos el ACM en todas las columnas seleccionadas:
```{r ACM}
require(ca) 
cis_2020_equo_ca_00 <- mjca(cis_2020_EB_df[, included_cols_EB_idx])
```

Por defecto la función `mjca` toma el método de escalado `lambda = "adjusted"`, con lo que únicamente se consideran los valores propios obtenidos en el ACM mayores que $\frac{1}{Q} =$
```{r echo=FALSE, results='asis'}
eigen_inertia_e <- 1/Q
cat("\\frac{1}{", Q, "} = ",round(1/Q, digits = 4), ".", sep = "")
```

```{r}
cis_2020_equo_ca_00_summ <- summary(cis_2020_equo_ca_00)
numDim <- length(which(cis_2020_equo_ca_00_summ$scree[,2] > (eigen_inertia_e/2)))
```
Por lo tanto en nuestro caso el número de dimensiones será:
```{r echo=FALSE, results='asis'}
cat(numDim)
```


## Datos objetivos y datos de opinión
Debemos tener en cuenta que hay una serie de variables que son datos objetivos de la persona como por ejemplo su provincia de empadronamiento. A estas características las llamaremos variables *ilustrativas*, que son:

```{r echo=FALSE, results='asis'}
# cat(paste0("'", included_cols_EB, "'", collapse = ", "), sep = "")
# 'PROV', 'MUN', 'CAPITAL', 'TIPO_TEL', 'SEXO', 'A0a', 'P10_2', 'P10_3', 'P10IMPRESA', 'P10DIGITAL', 'P10TV', 'P10RADIO', 'P11_1', 'P11_2', 'P11_3', 'P11_4', 'P11_5', 'P11_7', 'P12_1', 'P12_2', 'P12_3', 'P12_4', 'P12_5', 'P12_6', 'P12_7', 'P14A_11', 'P14A_12', 'P14A_2', 'P14A_21', 'P14A_1', 'P14A_18', 'P14A_95', 'P14A_98', 'P15A_11', 'P15A_12', 'P15A_2', 'P15A_21', 'P15A_1', 'P15A_18', 'P15A_95', 'P15A_98', 'P16', 'P16A_11', 'P16A_12', 'P16A_2', 'P16A_21', 'P16A_1', 'P16A_18', 'P16A_95', 'P16A_98', 'P17_3', 'P20A_2', 'PARTICIPACIONA', 'P27', 'RELIGION', 'ESTADOCIVIL', 'CNO11', 'RELALAB', 'IA_APLAZADA', 'IA_MODIFICADA', 'IA_SUPERVISADA', 'TAMUNI_GRUPO', 'EDAD_GRUPO', 'P1_GRUPO', 'P1A_GRUPO', 'P1B_GRUPO', 'P2_GRUPO', 'P3_1_GRUPO', 'P3_2_GRUPO', 'P3_3_GRUPO', 'P3_4_GRUPO', 'P4_GRUPO', 'P5_GRUPO', 'P5A_GRUPO', 'P6_GRUPO', 'P7_GRUPO', 'P8_1_GRUPO', 'P8_2_GRUPO', 'P8_3_GRUPO', 'P8_4_GRUPO', 'P9_GRUPO', 'P9A_GRUPO', 'P9B_GRUPO', 'P10_1_GRUPO', 'P10A_GRUPO', 'P10B_GRUPO', 'P10C_GRUPO', 'P10D_GRUPO', 'P13_1_GRUPO', 'P13_2_GRUPO', 'P13_3_GRUPO', 'P13_4_GRUPO', 'P13_5_GRUPO', 'P14_GRUPO', 'P15_GRUPO', 'P17_1_GRUPO', 'P17_2_GRUPO', 'P18_GRUPO', 'P18A_GRUPO', 'P18B_GRUPO', 'P19_GRUPO', 'P19A01_GRUPO', 'P19A02_GRUPO', 'P20_GRUPO', 'P20A_1_GRUPO', 'P21_GRUPO', 'P21A_GRUPO', 'P21B_1_GRUPO', 'P21B_2_GRUPO', 'P22_GRUPO', 'P23_GRUPO', 'P24_1_GRUPO', 'P24_2_GRUPO', 'P24_3_GRUPO', 'P24_4_GRUPO', 'P24_5_GRUPO', 'P24_6_GRUPO', 'P24_7_GRUPO', 'RECUVOTOA_GRUPO', 'P26_1_GRUPO', 'P26_2_GRUPO', 'P26_3_GRUPO', 'P26_4_GRUPO', 'P26_5_GRUPO', 'P26_6_GRUPO', 'P28_GRUPO', 'P29_GRUPO', 'PARTICIPACIONG_GRUPO', 'RECUVOTOG_GRUPO', 'ESCIDEOL_GRUPO', 'ESCIDEOLPAR_1_GRUPO', 'ESCIDEOLPAR_2_GRUPO', 'ESCIDEOLPAR_3_GRUPO', 'ESCIDEOLPAR_4_GRUPO', 'ESCIDEOLPAR_5_GRUPO', 'ESCIDEOLPAR_6_GRUPO', 'ESCIDEOLPAR_7_GRUPO', 'NIVELESTENTREV_GRUPO', 'FRECUENCIARELI_GRUPO', 'SITLAB_GRUPO', 'CLASESOCIAL_GRUPO', 'IA_E1_DIA_GRUPO', 'IA_E2_GRUPO', 'IA_E4_GRUPO', 'IA_C2_GRUPO', 'P19ACOM_GRUPO', 'RVAUTO20_GRUPO', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO', 'ESTUDIOS_GRUPO', 'CLASESUB_GRUPO'

# Select some illustrative variables
illustrative_vars <- c('PROV', 'MUN', 'CAPITAL', 'TIPO_TEL', 'SEXO', 'A0a', 
                       'PARTICIPACIONA', 'RECUVOTOA_GRUPO', 
                       'PARTICIPACIONG_GRUPO', 'RECUVOTOG_GRUPO', 
                       'ESTADOCIVIL', 'SITLAB_GRUPO', 'CNO11', 'RELALAB', 
                       'IA_APLAZADA', 'IA_MODIFICADA', 'IA_SUPERVISADA', 
                       'RVAUTO20_GRUPO', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO', 'ESTUDIOS_GRUPO', 
                       'TAMUNI_GRUPO', 'EDAD_GRUPO', 'P1_GRUPO', 'P1A_GRUPO', 'P1B_GRUPO', 'P2_GRUPO', 
                       'ESCUELA_GRUPO', 'NIVELESTENTREV_GRUPO', 
                       'IA_E1_DIA_GRUPO', 'IA_E2_GRUPO', 'IA_E4_GRUPO', 'IA_C2_GRUPO')

# illustrative_vars <- c('RECUVOTOA_GRUPO', 'RECUVOTOG_GRUPO', 'RVAUTO20_GRUPO', 'RVAUTO16_GRUPO', 'RECUERDO_GRUPO')
# Calculate spare variables
opinion_vars <- included_cols_EB[which(!(included_cols_EB %in% illustrative_vars))]

cat(paste0("`",illustrative_vars, "`", collapse = ", "), sep = "")

# length(illustrative_vars) + length(opinion_vars)
```

El resto de preguntas pueden considerarse de opinión. El ACM trata de ubicar los datos objetivos entre las diferentes escalas de opiniones.

Se realiza una primera tentativa de ACM sólo con las variables de opinión:
```{r ACM01}
cis_2020_ca_opi01 <- mjca(cis_2020_EB_df[,opinion_vars], nd = numDim)

cis_2020_ca_opi01_summ <- summary(cis_2020_ca_opi01)

plot.mjca(cis_2020_ca_opi01, labels = c(2,0))
```

Inercias de los autovalores principales:
```{r}
require(pander)
library(pander)
aux_tbl <- as.data.frame(cis_2020_ca_opi01_summ$scree[1:numDim,])
colnames(aux_tbl) <- c("Dim", "Valor", "%", "% acumul")
# panderOptions()
pander(aux_tbl, digits = c(1,5,3,3), keep.trailing.zeros = TRUE, caption = "Porcentaje de varianza explicada por cada autovalor.")
```


```{r}
# Create data frame with numDim columns. Each column is a factor and each row is the contribution
cis_2020_EB_ctr_df <- data.frame(matrix(ncol = numDim+1, nrow = length(cis_2020_ca_opi01_summ$columns$name)))
colnames(cis_2020_EB_ctr_df) <- c("name", paste0("k", seq(1:numDim)))

cis_2020_EB_ctr_df$name <- cis_2020_ca_opi01_summ$columns$name
# Contributions of each dimension
for (i in 1:numDim) {
  cis_2020_EB_ctr_df[,i+1] <- cis_2020_ca_opi01_summ$columns[,7+(i-1)*3]
}
```

Con 
```{r echo=FALSE, results='asis'}
cat(numDim)
```
 dimensiones se explica el 
```{r echo=FALSE, results='asis'}
# cat(round(100 * sum(cis_2020_ca_opi01$inertia.e[1:numDim]), digits = 1))
cat(cis_2020_ca_opi01_summ$scree[numDim,][4])
```
 % de la varianza.

Seleccionamos las modalidades más importantes de este factor, las que representan un
```{r echo=FALSE, results='asis'}
percet_eigenvalue <- 0.75
cat(100*percet_eigenvalue, "%")
```
 de esa dimensión.
 


Las primeras
```{r echo=FALSE, results='asis'}
cat(nModalidadesVisualiza <- 60)
```
 variables+modalidades que representan el primer factor y su porcentaje contribución son:

```{r}
cis_2020_ca_opi01_k1_ctr_sort <- base::sort(cis_2020_EB_ctr_df$k1, decreasing = TRUE, index.return = TRUE)

i <- round(percet_eigenvalue*sum(cis_2020_EB_ctr_df$k1))


# ESTAS AQUI   # ESTAS AQUI   # ESTAS AQUI   # ESTAS AQUI   # ESTAS AQUI   # ESTAS AQUI   
j <- length(which(cumsum(cis_2020_ca_opi01_k1_ctr_sort$x) <= i))

which.max(cumsum(cis_2020_ca_opi01_k1_ctr_sort$x) >= i)

sum(cis_2020_ca_opi01_k1_ctr_sort$x[1:j])
sum(cis_2020_EB_ctr_df$k1[cis_2020_ca_opi01_k1_ctr_sort$ix[1:j]])

#######################################################################################




require(pander)
aux_tbl <- data.frame(cbind(1:nModalidadesVisualiza,
                            cis_2020_ca_opi01_summ$columns$name[cis_2020_ca_opi01_k1_ctr_sort$ix[1:nModalidadesVisualiza]],
                            cis_2020_ca_opi01_k1_ctr_sort$x[1:nModalidadesVisualiza],
                            round(100*cis_2020_ca_opi01_k1_ctr_sort$x[1:nModalidadesVisualiza] / sum(cis_2020_ca_opi01_k1_ctr_sort$x), digits = 1)))
colnames(aux_tbl) <- c("n", "Variable:modalidad", "Contribución", "%")
pander(aux_tbl)
```

Estas representan el 
```{r echo=FALSE, results='asis'}
round(100*sum(cis_2020_ca_opi01_k1_ctr_sort$x[1:nModalidadesVisualiza])/ sum(cis_2020_ca_opi01_k1_ctr_sort$x), digits = 1)
```
 % del peso de ese factor. O sea que lo que mejor representa a los encuestados es `N.S.` y `N.C.` y esto no nos aporta *ninguna* información. Por tanto para realizar este ACM hay que tener en cuenta más dimensiones, o sea más factores.

```{r}
cis_2020_ca_opi01_k2_ctr_sort <- sort(cis_2020_EB_ctr_df$k2, decreasing = TRUE, index.return = TRUE)

require(pander)
aux_tbl <- data.frame(cbind(1:nModalidadesVisualiza,
                            cis_2020_ca_opi01_summ$columns$name[cis_2020_ca_opi01_k2_ctr_sort$ix[1:nModalidadesVisualiza]],
                            cis_2020_ca_opi01_k2_ctr_sort$x[1:nModalidadesVisualiza],
                            round(100*cis_2020_ca_opi01_k2_ctr_sort$x[1:nModalidadesVisualiza] / sum(cis_2020_ca_opi01_k2_ctr_sort$x), digits = 1)))
colnames(aux_tbl) <- c("n", "Variable:modalidad", "Contribución", "%")
pander(aux_tbl)
```

Estas representan el 
```{r echo=FALSE, results='asis'}
round(100*sum(cis_2020_ca_opi01_k2_ctr_sort$x[1:nModalidadesVisualiza])/ sum(cis_2020_ca_opi01_k2_ctr_sort$x), digits = 1)
```



```{r}
log4r::info(logger,  paste(Sys.time(), 'Ending script'))
```



***

\pagebreak


---
